{"ast":null,"code":"/*!\n * csurf\n * Copyright(c) 2011 Sencha Inc.\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module dependencies.\n * @private\n */\n\nvar Cookie = require('cookie');\n\nvar createError = require('http-errors');\n\nvar sign = require('cookie-signature').sign;\n\nvar Tokens = require('csrf');\n/**\n * Module exports.\n * @public\n */\n\n\nmodule.exports = csurf;\n/**\n * CSRF protection middleware.\n *\n * This middleware adds a `req.csrfToken()` function to make a token\n * which should be added to requests which mutate\n * state, within a hidden form field, query-string etc. This\n * token is validated against the visitor's session.\n *\n * @param {Object} options\n * @return {Function} middleware\n * @public\n */\n\nfunction csurf(options) {\n  var opts = options || {}; // get cookie options\n\n  var cookie = getCookieOptions(opts.cookie); // get session options\n\n  var sessionKey = opts.sessionKey || 'session'; // get value getter\n\n  var value = opts.value || defaultValue; // token repo\n\n  var tokens = new Tokens(opts); // ignored methods\n\n  var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods;\n\n  if (!Array.isArray(ignoreMethods)) {\n    throw new TypeError('option ignoreMethods must be an array');\n  } // generate lookup\n\n\n  var ignoreMethod = getIgnoredMethods(ignoreMethods);\n  return function csrf(req, res, next) {\n    // validate the configuration against request\n    if (!verifyConfiguration(req, sessionKey, cookie)) {\n      return next(new Error('misconfigured csrf'));\n    } // get the secret from the request\n\n\n    var secret = getSecret(req, sessionKey, cookie);\n    var token; // lazy-load token getter\n\n    req.csrfToken = function csrfToken() {\n      var sec = !cookie ? getSecret(req, sessionKey, cookie) : secret; // use cached token if secret has not changed\n\n      if (token && sec === secret) {\n        return token;\n      } // generate & set new secret\n\n\n      if (sec === undefined) {\n        sec = tokens.secretSync();\n        setSecret(req, res, sessionKey, sec, cookie);\n      } // update changed secret\n\n\n      secret = sec; // create new token\n\n      token = tokens.create(secret);\n      return token;\n    }; // generate & set secret\n\n\n    if (!secret) {\n      secret = tokens.secretSync();\n      setSecret(req, res, sessionKey, secret, cookie);\n    } // verify the incoming token\n\n\n    if (!ignoreMethod[req.method] && !tokens.verify(secret, value(req))) {\n      return next(createError(403, 'invalid csrf token', {\n        code: 'EBADCSRFTOKEN'\n      }));\n    }\n\n    next();\n  };\n}\n/**\n * Default value function, checking the `req.body`\n * and `req.query` for the CSRF token.\n *\n * @param {IncomingMessage} req\n * @return {String}\n * @api private\n */\n\n\nfunction defaultValue(req) {\n  return req.body && req.body._csrf || req.query && req.query._csrf || req.headers['csrf-token'] || req.headers['xsrf-token'] || req.headers['x-csrf-token'] || req.headers['x-xsrf-token'];\n}\n/**\n * Get options for cookie.\n *\n * @param {boolean|object} [options]\n * @returns {object}\n * @api private\n */\n\n\nfunction getCookieOptions(options) {\n  if (options !== true && typeof options !== 'object') {\n    return undefined;\n  }\n\n  var opts = Object.create(null); // defaults\n\n  opts.key = '_csrf';\n  opts.path = '/';\n\n  if (options && typeof options === 'object') {\n    for (var prop in options) {\n      var val = options[prop];\n\n      if (val !== undefined) {\n        opts[prop] = val;\n      }\n    }\n  }\n\n  return opts;\n}\n/**\n * Get a lookup of ignored methods.\n *\n * @param {array} methods\n * @returns {object}\n * @api private\n */\n\n\nfunction getIgnoredMethods(methods) {\n  var obj = Object.create(null);\n\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i].toUpperCase();\n    obj[method] = true;\n  }\n\n  return obj;\n}\n/**\n * Get the token secret from the request.\n *\n * @param {IncomingMessage} req\n * @param {String} sessionKey\n * @param {Object} [cookie]\n * @api private\n */\n\n\nfunction getSecret(req, sessionKey, cookie) {\n  // get the bag & key\n  var bag = getSecretBag(req, sessionKey, cookie);\n  var key = cookie ? cookie.key : 'csrfSecret';\n\n  if (!bag) {\n    throw new Error('misconfigured csrf');\n  } // return secret from bag\n\n\n  return bag[key];\n}\n/**\n * Get the token secret bag from the request.\n *\n * @param {IncomingMessage} req\n * @param {String} sessionKey\n * @param {Object} [cookie]\n * @api private\n */\n\n\nfunction getSecretBag(req, sessionKey, cookie) {\n  if (cookie) {\n    // get secret from cookie\n    var cookieKey = cookie.signed ? 'signedCookies' : 'cookies';\n    return req[cookieKey];\n  } else {\n    // get secret from session\n    return req[sessionKey];\n  }\n}\n/**\n * Set a cookie on the HTTP response.\n *\n * @param {OutgoingMessage} res\n * @param {string} name\n * @param {string} val\n * @param {Object} [options]\n * @api private\n */\n\n\nfunction setCookie(res, name, val, options) {\n  var data = Cookie.serialize(name, val, options);\n  var prev = res.getHeader('set-cookie') || [];\n  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];\n  res.setHeader('set-cookie', header);\n}\n/**\n * Set the token secret on the request.\n *\n * @param {IncomingMessage} req\n * @param {OutgoingMessage} res\n * @param {string} sessionKey\n * @param {string} val\n * @param {Object} [cookie]\n * @api private\n */\n\n\nfunction setSecret(req, res, sessionKey, val, cookie) {\n  if (cookie) {\n    // set secret on cookie\n    var value = val;\n\n    if (cookie.signed) {\n      value = 's:' + sign(val, req.secret);\n    }\n\n    setCookie(res, cookie.key, value, cookie);\n  } else {\n    // set secret on session\n    req[sessionKey].csrfSecret = val;\n  }\n}\n/**\n * Verify the configuration against the request.\n * @private\n */\n\n\nfunction verifyConfiguration(req, sessionKey, cookie) {\n  if (!getSecretBag(req, sessionKey, cookie)) {\n    return false;\n  }\n\n  if (cookie && cookie.signed && !req.secret) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/Users/tlarr/ffwebsite/node_modules/csurf/index.js"],"names":["Cookie","require","createError","sign","Tokens","module","exports","csurf","options","opts","cookie","getCookieOptions","sessionKey","value","defaultValue","tokens","ignoreMethods","undefined","Array","isArray","TypeError","ignoreMethod","getIgnoredMethods","csrf","req","res","next","verifyConfiguration","Error","secret","getSecret","token","csrfToken","sec","secretSync","setSecret","create","method","verify","code","body","_csrf","query","headers","Object","key","path","prop","val","methods","obj","i","length","toUpperCase","bag","getSecretBag","cookieKey","signed","setCookie","name","data","serialize","prev","getHeader","header","concat","setHeader","csrfSecret"],"mappings":"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","sourcesContent":["/*!\n * csurf\n * Copyright(c) 2011 Sencha Inc.\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Cookie = require('cookie')\nvar createError = require('http-errors')\nvar sign = require('cookie-signature').sign\nvar Tokens = require('csrf')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = csurf\n\n/**\n * CSRF protection middleware.\n *\n * This middleware adds a `req.csrfToken()` function to make a token\n * which should be added to requests which mutate\n * state, within a hidden form field, query-string etc. This\n * token is validated against the visitor's session.\n *\n * @param {Object} options\n * @return {Function} middleware\n * @public\n */\n\nfunction csurf (options) {\n  var opts = options || {}\n\n  // get cookie options\n  var cookie = getCookieOptions(opts.cookie)\n\n  // get session options\n  var sessionKey = opts.sessionKey || 'session'\n\n  // get value getter\n  var value = opts.value || defaultValue\n\n  // token repo\n  var tokens = new Tokens(opts)\n\n  // ignored methods\n  var ignoreMethods = opts.ignoreMethods === undefined\n    ? ['GET', 'HEAD', 'OPTIONS']\n    : opts.ignoreMethods\n\n  if (!Array.isArray(ignoreMethods)) {\n    throw new TypeError('option ignoreMethods must be an array')\n  }\n\n  // generate lookup\n  var ignoreMethod = getIgnoredMethods(ignoreMethods)\n\n  return function csrf (req, res, next) {\n    // validate the configuration against request\n    if (!verifyConfiguration(req, sessionKey, cookie)) {\n      return next(new Error('misconfigured csrf'))\n    }\n\n    // get the secret from the request\n    var secret = getSecret(req, sessionKey, cookie)\n    var token\n\n    // lazy-load token getter\n    req.csrfToken = function csrfToken () {\n      var sec = !cookie\n        ? getSecret(req, sessionKey, cookie)\n        : secret\n\n      // use cached token if secret has not changed\n      if (token && sec === secret) {\n        return token\n      }\n\n      // generate & set new secret\n      if (sec === undefined) {\n        sec = tokens.secretSync()\n        setSecret(req, res, sessionKey, sec, cookie)\n      }\n\n      // update changed secret\n      secret = sec\n\n      // create new token\n      token = tokens.create(secret)\n\n      return token\n    }\n\n    // generate & set secret\n    if (!secret) {\n      secret = tokens.secretSync()\n      setSecret(req, res, sessionKey, secret, cookie)\n    }\n\n    // verify the incoming token\n    if (!ignoreMethod[req.method] && !tokens.verify(secret, value(req))) {\n      return next(createError(403, 'invalid csrf token', {\n        code: 'EBADCSRFTOKEN'\n      }))\n    }\n\n    next()\n  }\n}\n\n/**\n * Default value function, checking the `req.body`\n * and `req.query` for the CSRF token.\n *\n * @param {IncomingMessage} req\n * @return {String}\n * @api private\n */\n\nfunction defaultValue (req) {\n  return (req.body && req.body._csrf) ||\n    (req.query && req.query._csrf) ||\n    (req.headers['csrf-token']) ||\n    (req.headers['xsrf-token']) ||\n    (req.headers['x-csrf-token']) ||\n    (req.headers['x-xsrf-token'])\n}\n\n/**\n * Get options for cookie.\n *\n * @param {boolean|object} [options]\n * @returns {object}\n * @api private\n */\n\nfunction getCookieOptions (options) {\n  if (options !== true && typeof options !== 'object') {\n    return undefined\n  }\n\n  var opts = Object.create(null)\n\n  // defaults\n  opts.key = '_csrf'\n  opts.path = '/'\n\n  if (options && typeof options === 'object') {\n    for (var prop in options) {\n      var val = options[prop]\n\n      if (val !== undefined) {\n        opts[prop] = val\n      }\n    }\n  }\n\n  return opts\n}\n\n/**\n * Get a lookup of ignored methods.\n *\n * @param {array} methods\n * @returns {object}\n * @api private\n */\n\nfunction getIgnoredMethods (methods) {\n  var obj = Object.create(null)\n\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i].toUpperCase()\n    obj[method] = true\n  }\n\n  return obj\n}\n\n/**\n * Get the token secret from the request.\n *\n * @param {IncomingMessage} req\n * @param {String} sessionKey\n * @param {Object} [cookie]\n * @api private\n */\n\nfunction getSecret (req, sessionKey, cookie) {\n  // get the bag & key\n  var bag = getSecretBag(req, sessionKey, cookie)\n  var key = cookie ? cookie.key : 'csrfSecret'\n\n  if (!bag) {\n    throw new Error('misconfigured csrf')\n  }\n\n  // return secret from bag\n  return bag[key]\n}\n\n/**\n * Get the token secret bag from the request.\n *\n * @param {IncomingMessage} req\n * @param {String} sessionKey\n * @param {Object} [cookie]\n * @api private\n */\n\nfunction getSecretBag (req, sessionKey, cookie) {\n  if (cookie) {\n    // get secret from cookie\n    var cookieKey = cookie.signed\n      ? 'signedCookies'\n      : 'cookies'\n\n    return req[cookieKey]\n  } else {\n    // get secret from session\n    return req[sessionKey]\n  }\n}\n\n/**\n * Set a cookie on the HTTP response.\n *\n * @param {OutgoingMessage} res\n * @param {string} name\n * @param {string} val\n * @param {Object} [options]\n * @api private\n */\n\nfunction setCookie (res, name, val, options) {\n  var data = Cookie.serialize(name, val, options)\n\n  var prev = res.getHeader('set-cookie') || []\n  var header = Array.isArray(prev) ? prev.concat(data)\n    : [prev, data]\n\n  res.setHeader('set-cookie', header)\n}\n\n/**\n * Set the token secret on the request.\n *\n * @param {IncomingMessage} req\n * @param {OutgoingMessage} res\n * @param {string} sessionKey\n * @param {string} val\n * @param {Object} [cookie]\n * @api private\n */\n\nfunction setSecret (req, res, sessionKey, val, cookie) {\n  if (cookie) {\n    // set secret on cookie\n    var value = val\n\n    if (cookie.signed) {\n      value = 's:' + sign(val, req.secret)\n    }\n\n    setCookie(res, cookie.key, value, cookie)\n  } else {\n    // set secret on session\n    req[sessionKey].csrfSecret = val\n  }\n}\n\n/**\n * Verify the configuration against the request.\n * @private\n */\n\nfunction verifyConfiguration (req, sessionKey, cookie) {\n  if (!getSecretBag(req, sessionKey, cookie)) {\n    return false\n  }\n\n  if (cookie && cookie.signed && !req.secret) {\n    return false\n  }\n\n  return true\n}\n"]},"metadata":{},"sourceType":"script"}