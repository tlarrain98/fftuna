{"ast":null,"code":"const jose = require('node-jose');\n\nconst assert = require('assert');\n\nconst util = require('util');\n\nconst url = require('url');\n\nconst _ = require('lodash');\n\nconst LRU = require('lru-cache');\n\nconst http = require('./http');\n\nconst httpRequest = require('./http_request');\n\nconst {\n  DEFAULT_HTTP_OPTIONS,\n  ISSUER_DEFAULTS,\n  DISCOVERY,\n  WEBFINGER,\n  REL\n} = require('./consts');\n\nconst errorHandler = require('./error_handler');\n\nconst BaseClient = require('./client');\n\nconst registry = require('./issuer_registry');\n\nconst expectResponseWithBody = require('./expect_response');\n\nconst webfingerNormalize = require('./webfinger_normalize');\n\nconst privateProps = new WeakMap();\n\nlet defaultHttpOptions = _.clone(DEFAULT_HTTP_OPTIONS);\n\nlet httpClient;\n\nfunction instance(ctx) {\n  if (!privateProps.has(ctx)) privateProps.set(ctx, {\n    metadata: {}\n  });\n  return privateProps.get(ctx);\n}\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata) {\n    const properties = Object.assign({}, ISSUER_DEFAULTS, metadata);\n    ['introspection', 'revocation'].forEach(endpoint => {\n      _.defaults(properties, {\n        [`${endpoint}_endpoint`]: properties[`token_${endpoint}_endpoint`],\n        // e.g. defaults introspection_endpoint to token_introspection_endpoint value\n        [`${endpoint}_endpoint_auth_methods_supported`]: properties.token_endpoint_auth_methods_supported,\n        [`${endpoint}_endpoint_auth_signing_alg_values_supported`]: properties.token_endpoint_auth_signing_alg_values_supported\n      });\n    });\n\n    _.forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).metadata[key];\n          }\n\n        });\n      }\n    });\n\n    instance(this).cache = new LRU({\n      max: 100\n    });\n    registry.set(this.issuer, this);\n    const self = this;\n    Object.defineProperty(this, 'Client', {\n      value: class Client extends BaseClient {\n        static get issuer() {\n          return self;\n        }\n\n        get issuer() {\n          return this.constructor.issuer;\n        }\n\n      }\n    });\n  }\n  /**\n   * @name inspect\n   * @api public\n   */\n\n\n  inspect() {\n    return util.format('Issuer <%s>', this.issuer);\n  }\n  /**\n   * @name keystore\n   * @api private\n   */\n\n\n  keystore(reload) {\n    if (!this.jwks_uri) return Promise.reject(new Error('jwks_uri must be configured'));\n    const {\n      keystore,\n      cache\n    } = instance(this);\n\n    if (reload || !keystore) {\n      cache.reset();\n      return this.httpClient.get(this.jwks_uri, this.httpOptions()).then(expectResponseWithBody(200)).then(response => JSON.parse(response.body)).then(jwks => jose.JWK.asKeyStore(jwks)).then(joseKeyStore => {\n        cache.set('throttle', true, 60 * 1000);\n        instance(this).keystore = joseKeyStore;\n        return joseKeyStore;\n      }).catch(errorHandler.bind(this));\n    }\n\n    return Promise.resolve(keystore);\n  }\n  /**\n   * @name key\n   * @api private\n   */\n\n\n  key(def, allowMulti) {\n    const {\n      cache\n    } = instance(this); // refresh keystore on every unknown key but also only upto once every minute\n\n    const freshJwksUri = cache.get(def) || cache.get('throttle');\n    return this.keystore(!freshJwksUri).then(store => store.all(def)).then(keys => {\n      assert(keys.length, 'no valid key found');\n\n      if (!allowMulti) {\n        assert.equal(keys.length, 1, 'multiple matching keys, kid must be provided');\n        cache.set(def, true);\n      }\n\n      return keys[0];\n    });\n  }\n  /**\n   * @name metadata\n   * @api public\n   */\n\n\n  get metadata() {\n    return instance(this).metadata;\n  }\n  /**\n   * @name webfinger\n   * @api public\n   */\n\n\n  static webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const {\n      host\n    } = url.parse(resource);\n    const query = {\n      resource,\n      rel: REL\n    };\n    const opts = {\n      query,\n      followRedirect: true\n    };\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n    return this.httpClient.get(webfingerUrl, this.httpOptions(opts)).then(expectResponseWithBody(200)).then(response => JSON.parse(response.body)).then(body => {\n      const location = _.find(body.links, link => typeof link === 'object' && link.rel === REL && link.href);\n\n      assert(location, 'no issuer found in webfinger');\n      assert(typeof location.href === 'string' && location.href.startsWith('https://'), 'invalid issuer location');\n      const expectedIssuer = location.href;\n      if (registry.has(expectedIssuer)) return registry.get(expectedIssuer);\n      return this.discover(expectedIssuer).then(issuer => {\n        try {\n          assert.equal(issuer.issuer, expectedIssuer, 'discovered issuer mismatch');\n        } catch (err) {\n          registry.delete(issuer.issuer);\n          throw err;\n        }\n\n        return issuer;\n      });\n    });\n  }\n  /**\n   * @name discover\n   * @api public\n   */\n\n\n  static discover(uri) {\n    const parsed = url.parse(uri);\n    let wellKnownUri;\n\n    if (parsed.pathname.endsWith(DISCOVERY)) {\n      wellKnownUri = uri;\n    } else {\n      if (parsed.pathname.endsWith('/')) {\n        parsed.pathname = `${parsed.pathname}${DISCOVERY.substring(1)}`;\n      } else {\n        parsed.pathname = `${parsed.pathname}${DISCOVERY}`;\n      }\n\n      wellKnownUri = url.format(parsed);\n    }\n\n    return this.httpClient.get(wellKnownUri, this.httpOptions()).then(expectResponseWithBody(200)).then(response => new this(JSON.parse(response.body))).catch(errorHandler.bind(this));\n  }\n\n  static useGot() {\n    this.httpClient = http;\n  }\n\n  static useRequest() {\n    this.httpClient = httpRequest();\n  }\n\n  get httpClient() {\n    return this.constructor.httpClient;\n  }\n\n  static get httpClient() {\n    return httpClient;\n  }\n\n  static set httpClient(client) {\n    assert.equal(typeof client.get, 'function', 'client.get must be a function');\n    assert.equal(typeof client.post, 'function', 'client.post must be a function');\n    assert(client.HTTPError, 'client.HTTPError must be a constructor');\n    httpClient = client;\n  }\n  /**\n   * @name httpOptions\n   * @api public\n   */\n\n\n  httpOptions(...args) {\n    return this.constructor.httpOptions(...args);\n  }\n  /**\n   * @name httpOptions\n   * @api public\n   */\n\n\n  static httpOptions(values) {\n    return _.merge({}, this.defaultHttpOptions, values);\n  }\n  /**\n   * @name defaultHttpOptions\n   * @api public\n   */\n\n\n  static get defaultHttpOptions() {\n    return defaultHttpOptions;\n  }\n  /**\n   * @name defaultHttpOptions=\n   * @api public\n   */\n\n\n  static set defaultHttpOptions(value) {\n    defaultHttpOptions = _.merge({}, DEFAULT_HTTP_OPTIONS, value);\n  }\n\n}\n\nIssuer.useGot();\nmodule.exports = Issuer;","map":{"version":3,"sources":["C:/Users/tlarr/ffwebsite/node_modules/openid-client/lib/issuer.js"],"names":["jose","require","assert","util","url","_","LRU","http","httpRequest","DEFAULT_HTTP_OPTIONS","ISSUER_DEFAULTS","DISCOVERY","WEBFINGER","REL","errorHandler","BaseClient","registry","expectResponseWithBody","webfingerNormalize","privateProps","WeakMap","defaultHttpOptions","clone","httpClient","instance","ctx","has","set","metadata","get","Issuer","constructor","properties","Object","assign","forEach","endpoint","defaults","token_endpoint_auth_methods_supported","token_endpoint_auth_signing_alg_values_supported","value","key","defineProperty","cache","max","issuer","self","Client","inspect","format","keystore","reload","jwks_uri","Promise","reject","Error","reset","httpOptions","then","response","JSON","parse","body","jwks","JWK","asKeyStore","joseKeyStore","catch","bind","resolve","def","allowMulti","freshJwksUri","store","all","keys","length","equal","webfinger","input","resource","host","query","rel","opts","followRedirect","webfingerUrl","location","find","links","link","href","startsWith","expectedIssuer","discover","err","delete","uri","parsed","wellKnownUri","pathname","endsWith","substring","useGot","useRequest","client","post","HTTPError","args","values","merge","module","exports"],"mappings":"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","sourcesContent":["const jose = require('node-jose');\nconst assert = require('assert');\nconst util = require('util');\nconst url = require('url');\nconst _ = require('lodash');\nconst LRU = require('lru-cache');\nconst http = require('./http');\nconst httpRequest = require('./http_request');\n\nconst {\n  DEFAULT_HTTP_OPTIONS,\n  ISSUER_DEFAULTS,\n  DISCOVERY,\n  WEBFINGER,\n  REL,\n} = require('./consts');\n\nconst errorHandler = require('./error_handler');\nconst BaseClient = require('./client');\nconst registry = require('./issuer_registry');\nconst expectResponseWithBody = require('./expect_response');\nconst webfingerNormalize = require('./webfinger_normalize');\n\nconst privateProps = new WeakMap();\n\nlet defaultHttpOptions = _.clone(DEFAULT_HTTP_OPTIONS);\nlet httpClient;\n\nfunction instance(ctx) {\n  if (!privateProps.has(ctx)) privateProps.set(ctx, { metadata: {} });\n  return privateProps.get(ctx);\n}\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata) {\n    const properties = Object.assign({}, ISSUER_DEFAULTS, metadata);\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      _.defaults(properties, {\n        [`${endpoint}_endpoint`]: properties[`token_${endpoint}_endpoint`], // e.g. defaults introspection_endpoint to token_introspection_endpoint value\n        [`${endpoint}_endpoint_auth_methods_supported`]: properties.token_endpoint_auth_methods_supported,\n        [`${endpoint}_endpoint_auth_signing_alg_values_supported`]: properties.token_endpoint_auth_signing_alg_values_supported,\n      });\n    });\n\n    _.forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).metadata[key]; },\n        });\n      }\n    });\n\n    instance(this).cache = new LRU({ max: 100 });\n\n    registry.set(this.issuer, this);\n\n    const self = this;\n\n    Object.defineProperty(this, 'Client', {\n      value: class Client extends BaseClient {\n        static get issuer() {\n          return self;\n        }\n\n        get issuer() {\n          return this.constructor.issuer;\n        }\n      },\n    });\n  }\n\n  /**\n   * @name inspect\n   * @api public\n   */\n  inspect() {\n    return util.format('Issuer <%s>', this.issuer);\n  }\n\n  /**\n   * @name keystore\n   * @api private\n   */\n  keystore(reload) {\n    if (!this.jwks_uri) return Promise.reject(new Error('jwks_uri must be configured'));\n\n    const { keystore, cache } = instance(this);\n\n    if (reload || !keystore) {\n      cache.reset();\n      return this.httpClient.get(this.jwks_uri, this.httpOptions())\n        .then(expectResponseWithBody(200))\n        .then(response => JSON.parse(response.body))\n        .then(jwks => jose.JWK.asKeyStore(jwks))\n        .then((joseKeyStore) => {\n          cache.set('throttle', true, 60 * 1000);\n          instance(this).keystore = joseKeyStore;\n          return joseKeyStore;\n        })\n        .catch(errorHandler.bind(this));\n    }\n\n    return Promise.resolve(keystore);\n  }\n\n  /**\n   * @name key\n   * @api private\n   */\n  key(def, allowMulti) {\n    const { cache } = instance(this);\n\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(def) || cache.get('throttle');\n\n    return this.keystore(!freshJwksUri)\n      .then(store => store.all(def))\n      .then((keys) => {\n        assert(keys.length, 'no valid key found');\n        if (!allowMulti) {\n          assert.equal(keys.length, 1, 'multiple matching keys, kid must be provided');\n          cache.set(def, true);\n        }\n        return keys[0];\n      });\n  }\n\n  /**\n   * @name metadata\n   * @api public\n   */\n  get metadata() {\n    return instance(this).metadata;\n  }\n\n  /**\n   * @name webfinger\n   * @api public\n   */\n  static webfinger(input) {\n    const resource = webfingerNormalize(input);\n    const { host } = url.parse(resource);\n    const query = { resource, rel: REL };\n    const opts = { query, followRedirect: true };\n    const webfingerUrl = `https://${host}${WEBFINGER}`;\n\n    return this.httpClient.get(webfingerUrl, this.httpOptions(opts))\n      .then(expectResponseWithBody(200))\n      .then(response => JSON.parse(response.body))\n      .then((body) => {\n        const location = _.find(body.links, link => typeof link === 'object' && link.rel === REL && link.href);\n        assert(location, 'no issuer found in webfinger');\n        assert(typeof location.href === 'string' && location.href.startsWith('https://'), 'invalid issuer location');\n        const expectedIssuer = location.href;\n        if (registry.has(expectedIssuer)) return registry.get(expectedIssuer);\n\n        return this.discover(expectedIssuer).then((issuer) => {\n          try {\n            assert.equal(issuer.issuer, expectedIssuer, 'discovered issuer mismatch');\n          } catch (err) {\n            registry.delete(issuer.issuer);\n            throw err;\n          }\n          return issuer;\n        });\n      });\n  }\n\n  /**\n   * @name discover\n   * @api public\n   */\n  static discover(uri) {\n    const parsed = url.parse(uri);\n\n    let wellKnownUri;\n    if (parsed.pathname.endsWith(DISCOVERY)) {\n      wellKnownUri = uri;\n    } else {\n      if (parsed.pathname.endsWith('/')) {\n        parsed.pathname = `${parsed.pathname}${DISCOVERY.substring(1)}`;\n      } else {\n        parsed.pathname = `${parsed.pathname}${DISCOVERY}`;\n      }\n      wellKnownUri = url.format(parsed);\n    }\n\n    return this.httpClient.get(wellKnownUri, this.httpOptions())\n      .then(expectResponseWithBody(200))\n      .then(response => new this(JSON.parse(response.body)))\n      .catch(errorHandler.bind(this));\n  }\n\n  static useGot() {\n    this.httpClient = http;\n  }\n\n  static useRequest() {\n    this.httpClient = httpRequest();\n  }\n\n  get httpClient() {\n    return this.constructor.httpClient;\n  }\n\n  static get httpClient() {\n    return httpClient;\n  }\n\n  static set httpClient(client) {\n    assert.equal(typeof client.get, 'function', 'client.get must be a function');\n    assert.equal(typeof client.post, 'function', 'client.post must be a function');\n    assert(client.HTTPError, 'client.HTTPError must be a constructor');\n    httpClient = client;\n  }\n\n  /**\n   * @name httpOptions\n   * @api public\n   */\n  httpOptions(...args) {\n    return this.constructor.httpOptions(...args);\n  }\n\n  /**\n   * @name httpOptions\n   * @api public\n   */\n  static httpOptions(values) {\n    return _.merge({}, this.defaultHttpOptions, values);\n  }\n\n  /**\n   * @name defaultHttpOptions\n   * @api public\n   */\n  static get defaultHttpOptions() {\n    return defaultHttpOptions;\n  }\n\n  /**\n   * @name defaultHttpOptions=\n   * @api public\n   */\n  static set defaultHttpOptions(value) {\n    defaultHttpOptions = _.merge({}, DEFAULT_HTTP_OPTIONS, value);\n  }\n}\n\nIssuer.useGot();\n\nmodule.exports = Issuer;\n"]},"metadata":{},"sourceType":"script"}