{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nconst _ = require('lodash');\n\nconst uuid = require('uuid/v4');\n\nconst util = require('util');\n\nconst base64url = require('base64url');\n\nconst crypto = require('crypto');\n\nconst url = require('url');\n\nconst assert = require('assert');\n\nconst OpenIdConnectError = require('./open_id_connect_error');\n\nconst Client = require('./client');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n/**\n * @name constructor\n * @api public\n */\n\n\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false\n} = {}, verify) {\n  assert(client instanceof Client, 'client must be an instance of openid-client Client');\n  assert.equal(typeof verify, 'function', 'verify must be a function');\n  assert(client.issuer && client.issuer.issuer, 'client must have an issuer with an identifier');\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = params;\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n    assert(Array.isArray(supportedMethods), 'code_challenge_methods_supported is not properly set on issuer');\n    assert(supportedMethods.length, 'issuer code_challenge_methods_supported is empty');\n\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new Error('neither S256 or plain code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string') {\n    assert(['plain', 'S256'].includes(this._usePKCE), `${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n  if (!params.response_type) params.response_type = _.get(client, 'response_types[0]', 'code');\n  if (!params.redirect_uri) params.redirect_uri = _.get(client, 'redirect_uris[0]');\n  if (!params.scope) params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  const client = this._client;\n\n  try {\n    if (!req.session) {\n      throw new Error('authentication requires session support when using state, max_age or nonce');\n    }\n\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n    /* start authentication request */\n\n    if (_.isEmpty(reqParams)) {\n      // provide options object with extra authentication parameters\n      const params = _.defaults({}, options, this._params, {\n        state: uuid()\n      });\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = uuid();\n      }\n\n      req.session[sessionKey] = _.pick(params, 'nonce', 'state', 'max_age');\n\n      if (this._usePKCE) {\n        const verifier = uuid();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) {\n          // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = base64url.encode(crypto.createHash('sha256').update(verifier).digest());\n            params.code_challenge_method = 'S256';\n            break;\n\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n\n    const session = req.session[sessionKey];\n\n    const state = _.get(session, 'state');\n\n    const maxAge = _.get(session, 'max_age');\n\n    const nonce = _.get(session, 'nonce');\n\n    const codeVerifier = _.get(session, 'code_verifier');\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = _.defaults({}, options, {\n      redirect_uri: this._params.redirect_uri\n    });\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier\n    };\n    let callback = client.authorizationCallback(opts.redirect_uri, reqParams, checks).then(tokenset => {\n      const result = {\n        tokenset\n      };\n      return result;\n    });\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    if (loadUserinfo) {\n      callback = callback.then(result => {\n        if (result.tokenset.access_token) {\n          const userinfoRequest = client.userinfo(result.tokenset);\n          return userinfoRequest.then(userinfo => {\n            result.userinfo = userinfo;\n            return result;\n          });\n        }\n\n        return result;\n      });\n    }\n\n    callback.then(result => {\n      const args = [result.tokenset, verified.bind(this)];\n      if (loadUserinfo) args.splice(1, 0, result.userinfo);\n      if (passReq) args.unshift(req);\n\n      this._verify(...args);\n    }).catch(error => {\n      if (error instanceof OpenIdConnectError && error.error !== 'server_error' && !error.error.startsWith('invalid')) {\n        this.fail(error);\n      } else if (error.message === 'state mismatch' && !state) {\n        this.error(new Error(util.format('state mismatch, could not find a state in the session, this is likely an environment setup issue, loaded session: %j', session)));\n      } else {\n        this.error(error);\n      }\n    });\n    /* end authentication response */\n  } catch (err) {\n    this.error(err);\n  }\n};\n\nmodule.exports = OpenIDConnectStrategy;","map":{"version":3,"sources":["C:/Users/tlarr/ffwebsite/node_modules/openid-client/lib/passport_strategy.js"],"names":["_","require","uuid","util","base64url","crypto","url","assert","OpenIdConnectError","Client","verified","err","user","info","error","fail","success","OpenIDConnectStrategy","client","params","passReqToCallback","sessionKey","usePKCE","verify","equal","issuer","_client","_issuer","_verify","_passReqToCallback","_usePKCE","_key","parse","hostname","_params","supportedMethods","code_challenge_methods_supported","Array","isArray","length","includes","Error","name","response_type","get","redirect_uri","scope","prototype","authenticate","req","options","session","reqParams","callbackParams","isEmpty","defaults","state","nonce","pick","verifier","code_verifier","code_challenge","encode","createHash","update","digest","code_challenge_method","redirect","authorizationUrl","maxAge","codeVerifier","opts","checks","max_age","callback","authorizationCallback","then","tokenset","result","passReq","loadUserinfo","userinfo_endpoint","access_token","userinfoRequest","userinfo","args","bind","splice","unshift","catch","startsWith","message","format","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-underscore-dangle */\n\nconst _ = require('lodash');\nconst uuid = require('uuid/v4');\nconst util = require('util');\nconst base64url = require('base64url');\nconst crypto = require('crypto');\nconst url = require('url');\nconst assert = require('assert');\nconst OpenIdConnectError = require('./open_id_connect_error');\nconst Client = require('./client');\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n\n/**\n * @name constructor\n * @api public\n */\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false,\n} = {}, verify) {\n  assert(client instanceof Client, 'client must be an instance of openid-client Client');\n  assert.equal(typeof verify, 'function', 'verify must be a function');\n\n  assert(client.issuer && client.issuer.issuer, 'client must have an issuer with an identifier');\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n  this._params = params;\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n    assert(Array.isArray(supportedMethods), 'code_challenge_methods_supported is not properly set on issuer');\n    assert(supportedMethods.length, 'issuer code_challenge_methods_supported is empty');\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new Error('neither S256 or plain code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string') {\n    assert(['plain', 'S256'].includes(this._usePKCE), `${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n\n  if (!params.response_type) params.response_type = _.get(client, 'response_types[0]', 'code');\n  if (!params.redirect_uri) params.redirect_uri = _.get(client, 'redirect_uris[0]');\n  if (!params.scope) params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  const client = this._client;\n  try {\n    if (!req.session) {\n      throw new Error('authentication requires session support when using state, max_age or nonce');\n    }\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n\n    /* start authentication request */\n    if (_.isEmpty(reqParams)) {\n      // provide options object with extra authentication parameters\n      const params = _.defaults({}, options, this._params, {\n        state: uuid(),\n      });\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = uuid();\n      }\n\n      req.session[sessionKey] = _.pick(params, 'nonce', 'state', 'max_age');\n\n      if (this._usePKCE) {\n        const verifier = uuid();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) { // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = base64url.encode(crypto.createHash('sha256').update(verifier).digest());\n            params.code_challenge_method = 'S256';\n            break;\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n    const session = req.session[sessionKey];\n    const state = _.get(session, 'state');\n    const maxAge = _.get(session, 'max_age');\n    const nonce = _.get(session, 'nonce');\n    const codeVerifier = _.get(session, 'code_verifier');\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = _.defaults({}, options, {\n      redirect_uri: this._params.redirect_uri,\n    });\n\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n    };\n\n    let callback = client.authorizationCallback(opts.redirect_uri, reqParams, checks)\n      .then((tokenset) => {\n        const result = { tokenset };\n        return result;\n      });\n\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n\n    if (loadUserinfo) {\n      callback = callback.then((result) => {\n        if (result.tokenset.access_token) {\n          const userinfoRequest = client.userinfo(result.tokenset);\n          return userinfoRequest.then((userinfo) => {\n            result.userinfo = userinfo;\n            return result;\n          });\n        }\n\n        return result;\n      });\n    }\n\n    callback.then((result) => {\n      const args = [result.tokenset, verified.bind(this)];\n\n      if (loadUserinfo) args.splice(1, 0, result.userinfo);\n      if (passReq) args.unshift(req);\n\n      this._verify(...args);\n    }).catch((error) => {\n      if (error instanceof OpenIdConnectError &&\n            error.error !== 'server_error' &&\n            !error.error.startsWith('invalid')) {\n        this.fail(error);\n      } else if (error.message === 'state mismatch' && !state) {\n        this.error(new Error(util.format(\n          'state mismatch, could not find a state in the session, this is likely an environment setup issue, loaded session: %j',\n          session\n        )));\n      } else {\n        this.error(error);\n      }\n    });\n    /* end authentication response */\n  } catch (err) {\n    this.error(err);\n  }\n};\n\nmodule.exports = OpenIDConnectStrategy;\n"]},"metadata":{},"sourceType":"script"}