{"ast":null,"code":"const util = require('util');\n\nconst assert = require('assert');\n\nconst stdhttp = require('http');\n\nconst crypto = require('crypto');\n\nconst querystring = require('querystring');\n\nconst jose = require('node-jose');\n\nconst uuid = require('uuid/v4');\n\nconst base64url = require('base64url');\n\nconst url = require('url');\n\nconst _ = require('lodash');\n\nconst tokenHash = require('oidc-token-hash');\n\nconst errorHandler = require('./error_handler');\n\nconst expectResponseWithBody = require('./expect_response');\n\nconst TokenSet = require('./token_set');\n\nconst OpenIdConnectError = require('./open_id_connect_error');\n\nconst now = require('./unix_timestamp');\n\nconst {\n  CALLBACK_PROPERTIES,\n  CLIENT_DEFAULTS,\n  JWT_CONTENT\n} = require('./consts');\n\nconst issuerRegistry = require('./issuer_registry');\n\nconst map = new WeakMap();\nconst format = 'compact';\n\nfunction formUrlEncode(value) {\n  return encodeURIComponent(value).replace(/%20/g, '+');\n}\n\nfunction bearer(token) {\n  return `Bearer ${token}`;\n}\n\nfunction instance(ctx) {\n  if (!map.has(ctx)) map.set(ctx, {\n    metadata: {}\n  });\n  return map.get(ctx);\n}\n\nfunction cleanUpClaims(claims) {\n  if (_.isEmpty(claims._claim_names)) delete claims._claim_names;\n  if (_.isEmpty(claims._claim_sources)) delete claims._claim_sources;\n  return claims;\n}\n\nfunction assignClaim(target, source, sourceName) {\n  return (inSource, claim) => {\n    if (inSource === sourceName) {\n      assert(source[claim] !== undefined, `expected claim \"${claim}\" in \"${sourceName}\"`);\n      target[claim] = source[claim];\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction getFromJWT(jwt, position, claim) {\n  assert.equal(typeof jwt, 'string', 'invalid JWT type, expected a string');\n  const parts = jwt.split('.');\n  assert.equal(parts.length, 3, 'invalid JWT format, expected three parts');\n  const parsed = JSON.parse(base64url.decode(parts[position]));\n  return typeof claim === 'undefined' ? parsed : parsed[claim];\n}\n\nfunction getSub(jwt) {\n  return getFromJWT(jwt, 1, 'sub');\n}\n\nfunction getIss(jwt) {\n  return getFromJWT(jwt, 1, 'iss');\n}\n\nfunction getHeader(jwt) {\n  return getFromJWT(jwt, 0);\n}\n\nfunction getPayload(jwt) {\n  return getFromJWT(jwt, 1);\n}\n\nfunction assignErrSrc(sourceName) {\n  return err => {\n    err.src = sourceName;\n    throw err;\n  };\n}\n\nfunction authorizationParams(params) {\n  assert.equal(typeof params, 'object', 'you must provide an object');\n\n  const authParams = _.chain(params).defaults({\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: 'code'\n  }).forEach((value, key, object) => {\n    if (value === null || value === undefined) {\n      delete object[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      object[key] = JSON.stringify(value);\n    } else if (typeof value !== 'string') {\n      object[key] = String(value);\n    }\n  }).value();\n\n  assert(['none', 'code'].includes(authParams.response_type) || authParams.nonce, 'nonce MUST be provided for implicit and hybrid flows');\n  return authParams;\n}\n\nfunction claimJWT(jwt) {\n  try {\n    const iss = getIss(jwt);\n    const keyDef = getHeader(jwt);\n    assert(keyDef.alg, 'claim source is missing JWT header alg property');\n    if (keyDef.alg === 'none') return Promise.resolve(getPayload(jwt));\n\n    const getKey = (() => {\n      if (!iss || iss === this.issuer.issuer) {\n        return this.issuer.key(keyDef);\n      } else if (issuerRegistry.has(iss)) {\n        return issuerRegistry.get(iss).key(keyDef);\n      }\n\n      return this.issuer.constructor.discover(iss).then(issuer => issuer.key(keyDef));\n    })();\n\n    return getKey.then(key => jose.JWS.createVerify(key).verify(jwt)).then(result => JSON.parse(result.payload));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nfunction checkStore(keystore) {\n  assert(jose.JWK.isKeyStore(keystore), 'keystore must be an instance of jose.JWK.KeyStore');\n  assert(keystore.all().every(key => {\n    if (key.kty === 'RSA' || key.kty === 'EC') {\n      try {\n        key.toPEM(true);\n      } catch (err) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }), 'keystore must only contain private EC or RSA keys');\n} // if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\n\n\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nclass Client {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, keystore) {\n    const properties = Object.assign({}, CLIENT_DEFAULTS, metadata);\n\n    if (!metadata.token_endpoint_auth_method) {\n      // if no explicit value was provided\n      checkBasicSupport(this, metadata, properties);\n    }\n\n    if (String(properties.token_endpoint_auth_method).endsWith('_jwt')) {\n      assert(this.issuer.token_endpoint_auth_signing_alg_values_supported, 'token_endpoint_auth_signing_alg_values_supported must be provided on the issuer');\n    }\n\n    ['introspection', 'revocation'].forEach(endpoint => {\n      _.defaults(properties, {\n        [`${endpoint}_endpoint_auth_method`]: properties.token_endpoint_auth_method,\n        [`${endpoint}_endpoint_auth_signing_alg`]: properties.token_endpoint_auth_signing_alg\n      });\n\n      if (String(properties[`${endpoint}_endpoint_auth_method`]).endsWith('_jwt')) {\n        assert(this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`], `${endpoint}_endpoint_auth_signing_alg_values_supported must be provided on the issuer`);\n      }\n    });\n\n    _.forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).metadata[key];\n          }\n\n        });\n      }\n    });\n\n    if (keystore !== undefined) {\n      checkStore.call(this, keystore);\n      instance(this).keystore = keystore;\n    }\n\n    this.CLOCK_TOLERANCE = 0;\n  }\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n\n\n  authorizationUrl(params) {\n    assert(this.issuer.authorization_endpoint, 'authorization_endpoint must be configured');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    Object.assign(target.query, authorizationParams.call(this, params));\n    return url.format(target);\n  }\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n\n\n  authorizationPost(params) {\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs).map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n  /**\n   * @name callbackParams\n   * @api public\n   */\n\n\n  callbackParams(input) {\n    // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n    const isString = typeof input === 'string';\n    assert(isString || isIncomingMessage, '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    let uri;\n\n    if (isIncomingMessage) {\n      const msg = input;\n\n      switch (msg.method) {\n        case 'GET':\n          uri = msg.url;\n          break;\n\n        case 'POST':\n          assert(msg.body, 'incoming message body missing, include a body parser prior to this call');\n\n          switch (typeof msg.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(msg.body)) {\n                return querystring.parse(msg.body.toString('utf-8'));\n              } else if (typeof msg.body === 'string') {\n                return querystring.parse(msg.body);\n              }\n\n              return msg.body;\n\n            default:\n              throw new Error('invalid IncomingMessage body object');\n          }\n\n        default:\n          throw new Error('invalid IncomingMessage method');\n      }\n    } else {\n      uri = input;\n    }\n\n    return _.pick(url.parse(uri, true).query, CALLBACK_PROPERTIES);\n  }\n  /**\n   * @name authorizationCallback\n   * @api public\n   */\n\n\n  authorizationCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (this.default_max_age && !checks.max_age) checks.max_age = this.default_max_age;\n\n    if (checks.state !== parameters.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    let promise;\n\n    if (params.id_token) {\n      promise = Promise.resolve(new TokenSet(params)).then(tokenset => this.decryptIdToken(tokenset)).then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state));\n    }\n\n    if (params.code) {\n      const grantCall = () => this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n        state: checks.state\n      }).then(tokenset => this.decryptIdToken(tokenset)).then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age)).then(tokenset => {\n        if (params.session_state) tokenset.session_state = params.session_state;\n        return tokenset;\n      });\n\n      if (promise) {\n        promise = promise.then(grantCall);\n      } else {\n        return grantCall();\n      }\n    }\n\n    return promise || Promise.resolve(new TokenSet(params));\n  }\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n\n\n  oauthCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (checks.state !== parameters.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    if (params.code) {\n      return this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      });\n    }\n\n    return Promise.resolve(new TokenSet(params));\n  }\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n\n\n  decryptIdToken(token, use) {\n    if (!use) use = 'id_token'; // eslint-disable-line no-param-reassign\n\n    if (!this[`${use}_encrypted_response_alg`]) {\n      return Promise.resolve(token);\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this[`${use}_encrypted_response_alg`];\n    const expectedEnc = this[`${use}_encrypted_response_enc`];\n    const header = JSON.parse(base64url.decode(idToken.split('.')[0]));\n    assert.equal(header.alg, expectedAlg, 'unexpected alg received');\n    assert.equal(header.enc, expectedEnc, 'unexpected enc received');\n    const keystoreOrSecret = expectedAlg.match(/^(RSA|ECDH)/) ? Promise.resolve(instance(this).keystore) : this.joseSecret(expectedAlg);\n    return keystoreOrSecret.then(keyOrStore => jose.JWE.createDecrypt(keyOrStore).decrypt(idToken).then(result => {\n      if (token instanceof TokenSet) {\n        token.id_token = result.payload.toString('utf8');\n        return token;\n      }\n\n      return result.payload.toString('utf8');\n    }));\n  }\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n\n\n  validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = (() => {\n      if (returnedBy === 'userinfo') return this.userinfo_signed_response_alg;\n      return this.id_token_signed_response_alg;\n    })();\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n    const timestamp = now();\n    const parts = idToken.split('.');\n    const header = JSON.parse(base64url.decode(parts[0]));\n    const payload = JSON.parse(base64url.decode(parts[1]));\n\n    const verifyPresence = prop => {\n      if (payload[prop] === undefined) {\n        throw new Error(`missing required JWT property ${prop}`);\n      }\n    };\n\n    assert.equal(header.alg, expectedAlg, 'unexpected algorithm received');\n\n    if (returnedBy !== 'userinfo') {\n      ['iss', 'sub', 'aud', 'exp', 'iat'].forEach(verifyPresence);\n    }\n\n    if (payload.iss !== undefined) {\n      assert.equal(payload.iss, this.issuer.issuer, 'unexpected iss value');\n    }\n\n    if (payload.iat !== undefined) {\n      assert.equal(typeof payload.iat, 'number', 'iat is not a number');\n      assert(payload.iat <= timestamp + this.CLOCK_TOLERANCE, 'id_token issued in the future');\n    }\n\n    if (payload.nbf !== undefined) {\n      assert.equal(typeof payload.nbf, 'number', 'nbf is not a number');\n      assert(payload.nbf <= timestamp + this.CLOCK_TOLERANCE, 'id_token not active yet');\n    }\n\n    if (maxAge || maxAge !== null && this.require_auth_time) {\n      assert(payload.auth_time, 'missing required JWT property auth_time');\n      assert.equal(typeof payload.auth_time, 'number', 'auth_time is not a number');\n    }\n\n    if (maxAge) {\n      assert(payload.auth_time + maxAge >= timestamp - this.CLOCK_TOLERANCE, 'too much time has elapsed since the last End-User authentication');\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined)) {\n      assert.equal(payload.nonce, nonce, 'nonce mismatch');\n    }\n\n    if (payload.exp !== undefined) {\n      assert.equal(typeof payload.exp, 'number', 'exp is not a number');\n      assert(timestamp - this.CLOCK_TOLERANCE < payload.exp, 'id_token expired');\n    }\n\n    if (payload.aud !== undefined) {\n      if (!Array.isArray(payload.aud)) {\n        payload.aud = [payload.aud];\n      } else if (payload.aud.length > 1 && !payload.azp) {\n        throw new Error('missing required JWT property azp');\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      assert.equal(payload.azp, this.client_id, 'azp must be the client_id');\n    }\n\n    if (payload.aud !== undefined) {\n      assert(payload.aud.includes(this.client_id), 'aud is missing the client_id');\n    }\n\n    if (returnedBy === 'authorization') {\n      assert(payload.at_hash || !tokenSet.access_token, 'missing required property at_hash');\n      assert(payload.c_hash || !tokenSet.code, 'missing required property c_hash');\n\n      if (payload.s_hash) {\n        assert(state, 'cannot verify s_hash, state not provided');\n        assert(tokenHash(payload.s_hash, state, header.alg), 's_hash mismatch');\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      assert(tokenHash(payload.at_hash, tokenSet.access_token, header.alg), 'at_hash mismatch');\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      assert(tokenHash(payload.c_hash, tokenSet.code, header.alg), 'c_hash mismatch');\n    }\n\n    if (header.alg === 'none') {\n      return Promise.resolve(tokenSet);\n    }\n\n    return (header.alg.startsWith('HS') ? this.joseSecret() : this.issuer.key(header)).then(key => jose.JWS.createVerify(key).verify(idToken).catch(() => {\n      throw new Error('invalid signature');\n    })).then(() => tokenSet);\n  }\n  /**\n   * @name refresh\n   * @api public\n   */\n\n\n  refresh(refreshToken) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        return Promise.reject(new Error('refresh_token not present in TokenSet'));\n      }\n\n      token = token.refresh_token;\n    }\n\n    return this.grant({\n      grant_type: 'refresh_token',\n      refresh_token: String(token)\n    }).then(tokenset => {\n      if (!tokenset.id_token) {\n        return tokenset;\n      }\n\n      return this.decryptIdToken(tokenset).then(() => this.validateIdToken(tokenset, null, 'token', null));\n    });\n  }\n  /**\n   * @name userinfo\n   * @api public\n   */\n\n\n  userinfo(accessToken, options) {\n    let token = accessToken;\n\n    const opts = _.merge({\n      verb: 'get',\n      via: 'header'\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        return Promise.reject(new Error('access_token not present in TokenSet'));\n      }\n\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toLowerCase();\n    let httpOptions;\n\n    switch (opts.via) {\n      case 'query':\n        assert.equal(verb, 'get', 'providers should only parse query strings for GET requests');\n        httpOptions = {\n          query: {\n            access_token: token\n          }\n        };\n        break;\n\n      case 'body':\n        assert.equal(verb, 'post', 'can only send body on POST');\n        httpOptions = {\n          form: true,\n          body: {\n            access_token: token\n          }\n        };\n        break;\n\n      default:\n        httpOptions = {\n          headers: {\n            Authorization: bearer(token)\n          }\n        };\n    }\n\n    if (opts.params) {\n      if (verb === 'post') {\n        _.defaultsDeep(httpOptions, {\n          body: opts.params\n        });\n      } else {\n        _.defaultsDeep(httpOptions, {\n          query: opts.params\n        });\n      }\n    }\n\n    const {\n      issuer\n    } = this;\n    return this.httpClient[verb](issuer.userinfo_endpoint, issuer.httpOptions(httpOptions)).then(expectResponseWithBody(200)).then(response => {\n      if (JWT_CONTENT.exec(response.headers['content-type'])) {\n        return Promise.resolve(response.body).then(jwt => this.decryptIdToken(jwt, 'userinfo')).then(jwt => {\n          if (!this.userinfo_signed_response_alg) return JSON.parse(jwt);\n          return this.validateIdToken(jwt, null, 'userinfo', null).then(valid => JSON.parse(base64url.decode(valid.split('.')[1])));\n        });\n      }\n\n      return JSON.parse(response.body);\n    }).then(parsed => {\n      if (accessToken.id_token) {\n        assert.equal(parsed.sub, getSub(accessToken.id_token), 'userinfo sub mismatch');\n      }\n\n      return parsed;\n    }).catch(errorHandler.bind(this));\n  }\n  /**\n   * @name derivedKey\n   * @api private\n   */\n\n\n  derivedKey(len) {\n    const cacheKey = `${len}_key`;\n\n    if (instance(this)[cacheKey]) {\n      return Promise.resolve(instance(this)[cacheKey]);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256').update(this.client_secret).digest().slice(0, len / 8);\n    return jose.JWK.asKey({\n      k: base64url.encode(derivedBuffer),\n      kty: 'oct'\n    }).then(key => {\n      instance(this)[cacheKey] = key;\n      return key;\n    });\n  }\n  /**\n   * @name joseSecret\n   * @api private\n   */\n\n\n  joseSecret(alg) {\n    if (String(alg).match(/^(?:A|PBES2.+)(\\d{3})(GCM)?KW$/)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (instance(this).jose_secret) {\n      return Promise.resolve(instance(this).jose_secret);\n    }\n\n    return jose.JWK.asKey({\n      k: base64url.encode(this.client_secret),\n      kty: 'oct'\n    }).then(key => {\n      instance(this).jose_secret = key;\n      return key;\n    });\n  }\n  /**\n   * @name grant\n   * @api public\n   */\n\n\n  grant(body) {\n    assert(this.issuer.token_endpoint, 'issuer must be configured with token endpoint');\n    return this.authenticatedPost('token', {\n      body: _.omitBy(body, _.isUndefined)\n    }).then(expectResponseWithBody(200)).then(response => new TokenSet(JSON.parse(response.body)));\n  }\n  /**\n   * @name revoke\n   * @api public\n   */\n\n\n  revoke(token, hint) {\n    assert(this.issuer.revocation_endpoint, 'issuer must be configured with revocation endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n    const body = {\n      token\n    };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('revocation', {\n      body\n    }).then(response => {\n      if (response.body) {\n        return JSON.parse(response.body);\n      }\n\n      return {};\n    });\n  }\n  /**\n   * @name introspect\n   * @api public\n   */\n\n\n  introspect(token, hint) {\n    assert(this.issuer.introspection_endpoint, 'issuer must be configured with introspection endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n    const body = {\n      token\n    };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('introspection', {\n      body\n    }).then(expectResponseWithBody(200)).then(response => JSON.parse(response.body));\n  }\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n\n\n  fetchDistributedClaims(claims, tokens = {}) {\n    const distributedSources = _.pickBy(claims._claim_sources, def => !!def.endpoint);\n\n    return Promise.all(_.map(distributedSources, (def, sourceName) => {\n      const opts = {\n        headers: {\n          Authorization: bearer(def.access_token || tokens[sourceName])\n        }\n      };\n      return this.httpClient.get(def.endpoint, this.issuer.httpOptions(opts)).then(response => claimJWT.call(this, response.body), errorHandler.bind(this)).then(data => {\n        delete claims._claim_sources[sourceName];\n\n        _.forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n\n\n  unpackAggregatedClaims(claims) {\n    const aggregatedSources = _.pickBy(claims._claim_sources, def => !!def.JWT);\n\n    return Promise.all(_.map(aggregatedSources, (def, sourceName) => {\n      const decoded = claimJWT.call(this, def.JWT);\n      return decoded.then(data => {\n        delete claims._claim_sources[sourceName];\n\n        _.forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n  /**\n   * @name authenticatedPost\n   * @api private\n   */\n\n\n  authenticatedPost(endpoint, httpOptions) {\n    return Promise.resolve(this.authFor(endpoint)).then(auth => {\n      const opts = this.issuer.httpOptions(_.merge(httpOptions, auth, {\n        form: true\n      }));\n      return this.httpClient.post(this.issuer[`${endpoint}_endpoint`], opts);\n    }).catch(errorHandler.bind(this));\n  }\n  /**\n   * @name createSign\n   * @api private\n   */\n\n\n  createSign(endpoint) {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n\n    switch (this[`${endpoint}_endpoint_auth_method`]) {\n      case 'client_secret_jwt':\n        return this.joseSecret().then(key => {\n          if (!alg) {\n            alg = _.find(this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`], signAlg => key.algorithms('sign').includes(signAlg));\n          }\n\n          return jose.JWS.createSign({\n            fields: {\n              alg,\n              typ: 'JWT'\n            },\n            format\n          }, {\n            key,\n            reference: false\n          });\n        });\n\n      case 'private_key_jwt':\n        {\n          if (!alg) {\n            const algz = _.chain(instance(this).keystore.all()).map(key => key.algorithms('sign')).flatten().uniq().value();\n\n            alg = _.find(this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`], signAlg => algz.includes(signAlg));\n          }\n\n          const key = instance(this).keystore.get({\n            alg,\n            use: 'sig'\n          });\n          assert(key, 'no valid key found');\n          return Promise.resolve(jose.JWS.createSign({\n            fields: {\n              alg,\n              typ: 'JWT'\n            },\n            format\n          }, {\n            key,\n            reference: true\n          }));\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error('createSign only works for _jwt token auth methods');\n    }\n  }\n  /**\n   * @name authFor\n   * @api private\n   */\n\n\n  authFor(endpoint) {\n    switch (this[`${endpoint}_endpoint_auth_method`] || this.token_endpoint_auth_method) {\n      case 'none':\n        return {\n          body: {\n            client_id: this.client_id\n          }\n        };\n\n      case 'client_secret_post':\n        return {\n          body: {\n            client_id: this.client_id,\n            client_secret: this.client_secret\n          }\n        };\n\n      case 'private_key_jwt':\n      case 'client_secret_jwt':\n        {\n          const timestamp = now();\n          return this.createSign(endpoint).then(sign => sign.update(JSON.stringify({\n            iat: timestamp,\n            exp: timestamp + 60,\n            jti: uuid(),\n            iss: this.client_id,\n            sub: this.client_id,\n            aud: this.issuer[`${endpoint}_endpoint`]\n          })).final().then(client_assertion => {\n            // eslint-disable-line camelcase, arrow-body-style\n            return {\n              body: {\n                client_assertion,\n                client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n              }\n            };\n          }));\n        }\n\n      default:\n        {\n          const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n          const value = Buffer.from(encoded).toString('base64');\n          return {\n            headers: {\n              Authorization: `Basic ${value}`\n            }\n          };\n        }\n    }\n  }\n  /**\n   * @name inspect\n   * @api public\n   */\n\n\n  inspect() {\n    return util.format('Client <%s>', this.client_id);\n  }\n  /**\n   * @name register\n   * @api public\n   */\n\n\n  static register(properties, {\n    initialAccessToken,\n    keystore\n  } = {}) {\n    assert(this.issuer.registration_endpoint, 'issuer does not support dynamic registration');\n\n    if (keystore !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      checkStore.call(this, keystore);\n      properties.jwks = keystore.toJSON();\n    }\n\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    if (initialAccessToken) headers.Authorization = bearer(initialAccessToken);\n    return this.httpClient.post(this.issuer.registration_endpoint, this.issuer.httpOptions({\n      headers,\n      body: JSON.stringify(properties)\n    })).then(expectResponseWithBody(201)).then(response => new this(JSON.parse(response.body), keystore)).catch(errorHandler.bind(this));\n  }\n\n  get metadata() {\n    return instance(this).metadata;\n  }\n  /**\n   * @name fromUri\n   * @api public\n   */\n\n\n  static fromUri(uri, token, keystore) {\n    return this.httpClient.get(uri, this.issuer.httpOptions({\n      headers: {\n        Authorization: bearer(token)\n      }\n    })).then(expectResponseWithBody(200)).then(response => new this(JSON.parse(response.body), keystore), errorHandler.bind(this));\n  }\n  /**\n   * @name requestObject\n   * @api public\n   */\n\n\n  requestObject(request = {}, algorithms = {}) {\n    assert.equal(typeof request, 'object', 'pass an object as the first argument');\n\n    _.defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc\n      }\n    }, {\n      sign: 'none'\n    });\n\n    const signed = (() => {\n      const alg = algorithms.sign;\n      const header = {\n        alg,\n        typ: 'JWT'\n      };\n      const payload = JSON.stringify(_.defaults({}, request, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id\n      }));\n\n      if (alg === 'none') {\n        return Promise.resolve([base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.'));\n      }\n\n      const symmetrical = alg.startsWith('HS');\n\n      const getKey = (() => {\n        if (symmetrical) return this.joseSecret();\n        const {\n          keystore\n        } = instance(this);\n        assert(keystore, `no keystore present for client, cannot sign using ${alg}`);\n        const key = keystore.get({\n          alg,\n          use: 'sig'\n        });\n        assert(key, `no key to sign with found for ${alg}`);\n        return Promise.resolve(key);\n      })();\n\n      return getKey.then(key => jose.JWS.createSign({\n        fields: header,\n        format\n      }, {\n        key,\n        reference: !symmetrical\n      })).then(sign => sign.update(payload).final());\n    })();\n\n    if (!algorithms.encrypt.alg) return signed;\n    const fields = {\n      alg: algorithms.encrypt.alg,\n      enc: algorithms.encrypt.enc,\n      cty: 'JWT'\n    };\n    let keystoreOrSecret;\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      keystoreOrSecret = this.issuer.key({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc'\n      }, true);\n    } else {\n      keystoreOrSecret = this.joseSecret(fields.alg);\n    }\n    /* eslint-disable arrow-body-style */\n\n\n    return keystoreOrSecret.then(key => {\n      return signed.then(cleartext => {\n        return jose.JWE.createEncrypt({\n          format,\n          fields\n        }, {\n          key,\n          reference: key.kty !== 'oct'\n        }).update(cleartext).final();\n      });\n    });\n    /* eslint-enable arrow-body-style */\n  }\n\n  get httpClient() {\n    return this.issuer.httpClient;\n  }\n\n  static get httpClient() {\n    return this.issuer.httpClient;\n  }\n\n}\n\nmodule.exports = Client;","map":{"version":3,"sources":["C:/Users/tlarr/ffwebsite/node_modules/openid-client/lib/client.js"],"names":["util","require","assert","stdhttp","crypto","querystring","jose","uuid","base64url","url","_","tokenHash","errorHandler","expectResponseWithBody","TokenSet","OpenIdConnectError","now","CALLBACK_PROPERTIES","CLIENT_DEFAULTS","JWT_CONTENT","issuerRegistry","map","WeakMap","format","formUrlEncode","value","encodeURIComponent","replace","bearer","token","instance","ctx","has","set","metadata","get","cleanUpClaims","claims","isEmpty","_claim_names","_claim_sources","assignClaim","target","source","sourceName","inSource","claim","undefined","getFromJWT","jwt","position","equal","parts","split","length","parsed","JSON","parse","decode","getSub","getIss","getHeader","getPayload","assignErrSrc","err","src","authorizationParams","params","authParams","chain","defaults","client_id","scope","response_type","forEach","key","object","stringify","String","includes","nonce","claimJWT","iss","keyDef","alg","Promise","resolve","getKey","issuer","constructor","discover","then","JWS","createVerify","verify","result","payload","error","reject","checkStore","keystore","JWK","isKeyStore","all","every","kty","toPEM","checkBasicSupport","client","properties","supported","token_endpoint_auth_methods_supported","token_endpoint_auth_method","Client","Object","assign","endsWith","token_endpoint_auth_signing_alg_values_supported","endpoint","token_endpoint_auth_signing_alg","defineProperty","call","CLOCK_TOLERANCE","authorizationUrl","authorization_endpoint","search","query","authorizationPost","inputs","formInputs","keys","name","join","callbackParams","input","isIncomingMessage","IncomingMessage","method","isString","uri","msg","body","Buffer","isBuffer","toString","Error","pick","authorizationCallback","redirectUri","parameters","checks","default_max_age","max_age","state","promise","id_token","tokenset","decryptIdToken","validateIdToken","code","grantCall","grant","grant_type","redirect_uri","code_verifier","session_state","oauthCallback","use","idToken","expectedAlg","expectedEnc","header","enc","keystoreOrSecret","match","joseSecret","keyOrStore","JWE","createDecrypt","decrypt","tokenSet","returnedBy","maxAge","userinfo_signed_response_alg","id_token_signed_response_alg","isTokenSet","timestamp","verifyPresence","prop","iat","nbf","require_auth_time","auth_time","exp","aud","Array","isArray","azp","at_hash","access_token","c_hash","s_hash","startsWith","catch","refresh","refreshToken","refresh_token","userinfo","accessToken","options","opts","merge","verb","via","toLowerCase","httpOptions","form","headers","Authorization","defaultsDeep","httpClient","userinfo_endpoint","response","exec","valid","sub","bind","derivedKey","len","cacheKey","derivedBuffer","createHash","update","client_secret","digest","slice","asKey","k","encode","parseInt","RegExp","$1","jose_secret","token_endpoint","authenticatedPost","omitBy","isUndefined","revoke","hint","revocation_endpoint","token_type_hint","introspect","introspection_endpoint","fetchDistributedClaims","tokens","distributedSources","pickBy","def","data","unpackAggregatedClaims","aggregatedSources","JWT","decoded","authFor","auth","post","createSign","find","signAlg","algorithms","fields","typ","reference","algz","flatten","uniq","sign","jti","final","client_assertion","client_assertion_type","encoded","from","inspect","register","initialAccessToken","registration_endpoint","jwks","jwks_uri","toJSON","fromUri","requestObject","request","request_object_signing_alg","encrypt","request_object_encryption_alg","request_object_encryption_enc","signed","symmetrical","cty","cleartext","createEncrypt","module","exports"],"mappings":"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","sourcesContent":["const util = require('util');\nconst assert = require('assert');\nconst stdhttp = require('http');\nconst crypto = require('crypto');\nconst querystring = require('querystring');\nconst jose = require('node-jose');\nconst uuid = require('uuid/v4');\nconst base64url = require('base64url');\nconst url = require('url');\nconst _ = require('lodash');\nconst tokenHash = require('oidc-token-hash');\n\nconst errorHandler = require('./error_handler');\nconst expectResponseWithBody = require('./expect_response');\nconst TokenSet = require('./token_set');\nconst OpenIdConnectError = require('./open_id_connect_error');\nconst now = require('./unix_timestamp');\n\nconst { CALLBACK_PROPERTIES, CLIENT_DEFAULTS, JWT_CONTENT } = require('./consts');\n\nconst issuerRegistry = require('./issuer_registry');\n\nconst map = new WeakMap();\nconst format = 'compact';\n\nfunction formUrlEncode(value) {\n  return encodeURIComponent(value).replace(/%20/g, '+');\n}\n\nfunction bearer(token) {\n  return `Bearer ${token}`;\n}\n\nfunction instance(ctx) {\n  if (!map.has(ctx)) map.set(ctx, { metadata: {} });\n  return map.get(ctx);\n}\n\nfunction cleanUpClaims(claims) {\n  if (_.isEmpty(claims._claim_names)) delete claims._claim_names;\n  if (_.isEmpty(claims._claim_sources)) delete claims._claim_sources;\n  return claims;\n}\n\nfunction assignClaim(target, source, sourceName) {\n  return (inSource, claim) => {\n    if (inSource === sourceName) {\n      assert(source[claim] !== undefined, `expected claim \"${claim}\" in \"${sourceName}\"`);\n      target[claim] = source[claim];\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction getFromJWT(jwt, position, claim) {\n  assert.equal(typeof jwt, 'string', 'invalid JWT type, expected a string');\n  const parts = jwt.split('.');\n  assert.equal(parts.length, 3, 'invalid JWT format, expected three parts');\n  const parsed = JSON.parse(base64url.decode(parts[position]));\n  return typeof claim === 'undefined' ? parsed : parsed[claim];\n}\n\nfunction getSub(jwt) {\n  return getFromJWT(jwt, 1, 'sub');\n}\n\nfunction getIss(jwt) {\n  return getFromJWT(jwt, 1, 'iss');\n}\n\nfunction getHeader(jwt) {\n  return getFromJWT(jwt, 0);\n}\n\nfunction getPayload(jwt) {\n  return getFromJWT(jwt, 1);\n}\n\nfunction assignErrSrc(sourceName) {\n  return (err) => {\n    err.src = sourceName;\n    throw err;\n  };\n}\n\nfunction authorizationParams(params) {\n  assert.equal(typeof params, 'object', 'you must provide an object');\n\n  const authParams = _.chain(params).defaults({\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: 'code',\n  }).forEach((value, key, object) => {\n    if (value === null || value === undefined) {\n      delete object[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      object[key] = JSON.stringify(value);\n    } else if (typeof value !== 'string') {\n      object[key] = String(value);\n    }\n  }).value();\n\n  assert(\n    ['none', 'code'].includes(authParams.response_type) || authParams.nonce,\n    'nonce MUST be provided for implicit and hybrid flows'\n  );\n\n  return authParams;\n}\n\nfunction claimJWT(jwt) {\n  try {\n    const iss = getIss(jwt);\n    const keyDef = getHeader(jwt);\n    assert(keyDef.alg, 'claim source is missing JWT header alg property');\n\n    if (keyDef.alg === 'none') return Promise.resolve(getPayload(jwt));\n\n    const getKey = (() => {\n      if (!iss || iss === this.issuer.issuer) {\n        return this.issuer.key(keyDef);\n      } else if (issuerRegistry.has(iss)) {\n        return issuerRegistry.get(iss).key(keyDef);\n      }\n      return this.issuer.constructor.discover(iss).then(issuer => issuer.key(keyDef));\n    })();\n\n    return getKey\n      .then(key => jose.JWS.createVerify(key).verify(jwt))\n      .then(result => JSON.parse(result.payload));\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\nfunction checkStore(keystore) {\n  assert(jose.JWK.isKeyStore(keystore), 'keystore must be an instance of jose.JWK.KeyStore');\n  assert(keystore.all().every((key) => {\n    if (key.kty === 'RSA' || key.kty === 'EC') {\n      try { key.toPEM(true); } catch (err) { return false; }\n      return true;\n    }\n    return false;\n  }), 'keystore must only contain private EC or RSA keys');\n}\n\n\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nclass Client {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, keystore) {\n    const properties = Object.assign({}, CLIENT_DEFAULTS, metadata);\n\n    if (!metadata.token_endpoint_auth_method) { // if no explicit value was provided\n      checkBasicSupport(this, metadata, properties);\n    }\n\n    if (String(properties.token_endpoint_auth_method).endsWith('_jwt')) {\n      assert(\n        this.issuer.token_endpoint_auth_signing_alg_values_supported,\n        'token_endpoint_auth_signing_alg_values_supported must be provided on the issuer'\n      );\n    }\n\n    ['introspection', 'revocation'].forEach((endpoint) => {\n      _.defaults(properties, {\n        [`${endpoint}_endpoint_auth_method`]: properties.token_endpoint_auth_method,\n        [`${endpoint}_endpoint_auth_signing_alg`]: properties.token_endpoint_auth_signing_alg,\n      });\n      if (String(properties[`${endpoint}_endpoint_auth_method`]).endsWith('_jwt')) {\n        assert(\n          this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`],\n          `${endpoint}_endpoint_auth_signing_alg_values_supported must be provided on the issuer`\n        );\n      }\n    });\n\n\n    _.forEach(properties, (value, key) => {\n      instance(this).metadata[key] = value;\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() { return instance(this).metadata[key]; },\n        });\n      }\n    });\n\n    if (keystore !== undefined) {\n      checkStore.call(this, keystore);\n      instance(this).keystore = keystore;\n    }\n\n    this.CLOCK_TOLERANCE = 0;\n  }\n\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n  authorizationUrl(params) {\n    assert(this.issuer.authorization_endpoint, 'authorization_endpoint must be configured');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    Object.assign(target.query, authorizationParams.call(this, params));\n    return url.format(target);\n  }\n\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n  authorizationPost(params) {\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs)\n      .map(name => `<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join('\\n');\n\n    return `<!DOCTYPE html>\n<head>\n  <title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n  <form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n    ${formInputs}\n  </form>\n</body>\n</html>`;\n  }\n\n  /**\n   * @name callbackParams\n   * @api public\n   */\n  callbackParams(input) { // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage ||\n      (input && input.method && input.url);\n    const isString = typeof input === 'string';\n\n    assert(\n      isString || isIncomingMessage,\n      '#callbackParams only accepts string urls, http.IncomingMessage or a lookalike'\n    );\n\n    let uri;\n    if (isIncomingMessage) {\n      const msg = input;\n\n      switch (msg.method) {\n        case 'GET':\n          uri = msg.url;\n          break;\n        case 'POST':\n          assert(msg.body, 'incoming message body missing, include a body parser prior to this call');\n          switch (typeof msg.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(msg.body)) {\n                return querystring.parse(msg.body.toString('utf-8'));\n              } else if (typeof msg.body === 'string') {\n                return querystring.parse(msg.body);\n              }\n\n              return msg.body;\n            default:\n              throw new Error('invalid IncomingMessage body object');\n          }\n        default:\n          throw new Error('invalid IncomingMessage method');\n      }\n    } else {\n      uri = input;\n    }\n\n    return _.pick(url.parse(uri, true).query, CALLBACK_PROPERTIES);\n  }\n\n  /**\n   * @name authorizationCallback\n   * @api public\n   */\n  authorizationCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (this.default_max_age && !checks.max_age) checks.max_age = this.default_max_age;\n\n    if (checks.state !== parameters.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    let promise;\n\n    if (params.id_token) {\n      promise = Promise.resolve(new TokenSet(params))\n        .then(tokenset => this.decryptIdToken(tokenset))\n        .then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state));\n    }\n\n    if (params.code) {\n      const grantCall = () => this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n        state: checks.state,\n      })\n        .then(tokenset => this.decryptIdToken(tokenset))\n        .then(tokenset => this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age))\n        .then((tokenset) => {\n          if (params.session_state) tokenset.session_state = params.session_state;\n          return tokenset;\n        });\n\n      if (promise) {\n        promise = promise.then(grantCall);\n      } else {\n        return grantCall();\n      }\n    }\n\n    return promise || Promise.resolve(new TokenSet(params));\n  }\n\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n  oauthCallback(redirectUri, parameters, checks = {}) {\n    const params = _.pick(parameters, CALLBACK_PROPERTIES);\n\n    if (checks.state !== parameters.state) {\n      return Promise.reject(new Error('state mismatch'));\n    }\n\n    if (params.error) {\n      return Promise.reject(new OpenIdConnectError(params));\n    }\n\n    if (params.code) {\n      return this.grant({\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier,\n      });\n    }\n\n    return Promise.resolve(new TokenSet(params));\n  }\n\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n  decryptIdToken(token, use) {\n    if (!use) use = 'id_token'; // eslint-disable-line no-param-reassign\n\n    if (!this[`${use}_encrypted_response_alg`]) {\n      return Promise.resolve(token);\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this[`${use}_encrypted_response_alg`];\n    const expectedEnc = this[`${use}_encrypted_response_enc`];\n\n    const header = JSON.parse(base64url.decode(idToken.split('.')[0]));\n\n    assert.equal(header.alg, expectedAlg, 'unexpected alg received');\n    assert.equal(header.enc, expectedEnc, 'unexpected enc received');\n\n    const keystoreOrSecret = expectedAlg.match(/^(RSA|ECDH)/) ?\n      Promise.resolve(instance(this).keystore) : this.joseSecret(expectedAlg);\n\n    return keystoreOrSecret.then(keyOrStore => jose.JWE.createDecrypt(keyOrStore).decrypt(idToken)\n      .then((result) => {\n        if (token instanceof TokenSet) {\n          token.id_token = result.payload.toString('utf8');\n          return token;\n        }\n        return result.payload.toString('utf8');\n      }));\n  }\n\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n  validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n\n    const expectedAlg = (() => {\n      if (returnedBy === 'userinfo') return this.userinfo_signed_response_alg;\n      return this.id_token_signed_response_alg;\n    })();\n\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      assert(idToken.id_token, 'id_token not present in TokenSet');\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n\n    const timestamp = now();\n    const parts = idToken.split('.');\n    const header = JSON.parse(base64url.decode(parts[0]));\n    const payload = JSON.parse(base64url.decode(parts[1]));\n\n    const verifyPresence = (prop) => {\n      if (payload[prop] === undefined) {\n        throw new Error(`missing required JWT property ${prop}`);\n      }\n    };\n\n    assert.equal(header.alg, expectedAlg, 'unexpected algorithm received');\n\n    if (returnedBy !== 'userinfo') {\n      ['iss', 'sub', 'aud', 'exp', 'iat'].forEach(verifyPresence);\n    }\n\n    if (payload.iss !== undefined) {\n      assert.equal(payload.iss, this.issuer.issuer, 'unexpected iss value');\n    }\n\n    if (payload.iat !== undefined) {\n      assert.equal(typeof payload.iat, 'number', 'iat is not a number');\n      assert(payload.iat <= timestamp + this.CLOCK_TOLERANCE, 'id_token issued in the future');\n    }\n\n    if (payload.nbf !== undefined) {\n      assert.equal(typeof payload.nbf, 'number', 'nbf is not a number');\n      assert(payload.nbf <= timestamp + this.CLOCK_TOLERANCE, 'id_token not active yet');\n    }\n\n    if (maxAge || (maxAge !== null && this.require_auth_time)) {\n      assert(payload.auth_time, 'missing required JWT property auth_time');\n      assert.equal(typeof payload.auth_time, 'number', 'auth_time is not a number');\n    }\n\n    if (maxAge) {\n      assert(payload.auth_time + maxAge >= timestamp - this.CLOCK_TOLERANCE, 'too much time has elapsed since the last End-User authentication');\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined)) {\n      assert.equal(payload.nonce, nonce, 'nonce mismatch');\n    }\n\n    if (payload.exp !== undefined) {\n      assert.equal(typeof payload.exp, 'number', 'exp is not a number');\n      assert(timestamp - this.CLOCK_TOLERANCE < payload.exp, 'id_token expired');\n    }\n\n    if (payload.aud !== undefined) {\n      if (!Array.isArray(payload.aud)) {\n        payload.aud = [payload.aud];\n      } else if (payload.aud.length > 1 && !payload.azp) {\n        throw new Error('missing required JWT property azp');\n      }\n    }\n\n    if (payload.azp !== undefined) {\n      assert.equal(payload.azp, this.client_id, 'azp must be the client_id');\n    }\n\n    if (payload.aud !== undefined) {\n      assert(payload.aud.includes(this.client_id), 'aud is missing the client_id');\n    }\n\n    if (returnedBy === 'authorization') {\n      assert(payload.at_hash || !tokenSet.access_token, 'missing required property at_hash');\n      assert(payload.c_hash || !tokenSet.code, 'missing required property c_hash');\n\n      if (payload.s_hash) {\n        assert(state, 'cannot verify s_hash, state not provided');\n        assert(tokenHash(payload.s_hash, state, header.alg), 's_hash mismatch');\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      assert(tokenHash(payload.at_hash, tokenSet.access_token, header.alg), 'at_hash mismatch');\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      assert(tokenHash(payload.c_hash, tokenSet.code, header.alg), 'c_hash mismatch');\n    }\n\n    if (header.alg === 'none') {\n      return Promise.resolve(tokenSet);\n    }\n\n    return (header.alg.startsWith('HS') ? this.joseSecret() : this.issuer.key(header))\n      .then(key => jose.JWS.createVerify(key).verify(idToken).catch(() => {\n        throw new Error('invalid signature');\n      }))\n      .then(() => tokenSet);\n  }\n\n  /**\n   * @name refresh\n   * @api public\n   */\n  refresh(refreshToken) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        return Promise.reject(new Error('refresh_token not present in TokenSet'));\n      }\n      token = token.refresh_token;\n    }\n\n    return this.grant({\n      grant_type: 'refresh_token',\n      refresh_token: String(token),\n    })\n      .then((tokenset) => {\n        if (!tokenset.id_token) {\n          return tokenset;\n        }\n        return this.decryptIdToken(tokenset)\n          .then(() => this.validateIdToken(tokenset, null, 'token', null));\n      });\n  }\n\n  /**\n   * @name userinfo\n   * @api public\n   */\n  userinfo(accessToken, options) {\n    let token = accessToken;\n    const opts = _.merge({\n      verb: 'get',\n      via: 'header',\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        return Promise.reject(new Error('access_token not present in TokenSet'));\n      }\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toLowerCase();\n    let httpOptions;\n\n    switch (opts.via) {\n      case 'query':\n        assert.equal(verb, 'get', 'providers should only parse query strings for GET requests');\n        httpOptions = { query: { access_token: token } };\n        break;\n      case 'body':\n        assert.equal(verb, 'post', 'can only send body on POST');\n        httpOptions = { form: true, body: { access_token: token } };\n        break;\n      default:\n        httpOptions = { headers: { Authorization: bearer(token) } };\n    }\n\n    if (opts.params) {\n      if (verb === 'post') {\n        _.defaultsDeep(httpOptions, { body: opts.params });\n      } else {\n        _.defaultsDeep(httpOptions, { query: opts.params });\n      }\n    }\n\n    const { issuer } = this;\n    return this.httpClient[verb](issuer.userinfo_endpoint, issuer.httpOptions(httpOptions))\n      .then(expectResponseWithBody(200))\n      .then((response) => {\n        if (JWT_CONTENT.exec(response.headers['content-type'])) {\n          return Promise.resolve(response.body)\n            .then(jwt => this.decryptIdToken(jwt, 'userinfo'))\n            .then((jwt) => {\n              if (!this.userinfo_signed_response_alg) return JSON.parse(jwt);\n              return this.validateIdToken(jwt, null, 'userinfo', null)\n                .then(valid => JSON.parse(base64url.decode(valid.split('.')[1])));\n            });\n        }\n\n        return JSON.parse(response.body);\n      })\n      .then((parsed) => {\n        if (accessToken.id_token) {\n          assert.equal(parsed.sub, getSub(accessToken.id_token), 'userinfo sub mismatch');\n        }\n\n        return parsed;\n      })\n      .catch(errorHandler.bind(this));\n  }\n\n  /**\n   * @name derivedKey\n   * @api private\n   */\n  derivedKey(len) {\n    const cacheKey = `${len}_key`;\n    if (instance(this)[cacheKey]) {\n      return Promise.resolve(instance(this)[cacheKey]);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256')\n      .update(this.client_secret)\n      .digest()\n      .slice(0, len / 8);\n\n    return jose.JWK.asKey({ k: base64url.encode(derivedBuffer), kty: 'oct' }).then((key) => {\n      instance(this)[cacheKey] = key;\n      return key;\n    });\n  }\n\n  /**\n   * @name joseSecret\n   * @api private\n   */\n  joseSecret(alg) {\n    if (String(alg).match(/^(?:A|PBES2.+)(\\d{3})(GCM)?KW$/)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (instance(this).jose_secret) {\n      return Promise.resolve(instance(this).jose_secret);\n    }\n\n    return jose.JWK.asKey({ k: base64url.encode(this.client_secret), kty: 'oct' }).then((key) => {\n      instance(this).jose_secret = key;\n      return key;\n    });\n  }\n\n  /**\n   * @name grant\n   * @api public\n   */\n  grant(body) {\n    assert(this.issuer.token_endpoint, 'issuer must be configured with token endpoint');\n    return this.authenticatedPost('token', { body: _.omitBy(body, _.isUndefined) })\n      .then(expectResponseWithBody(200))\n      .then(response => new TokenSet(JSON.parse(response.body)));\n  }\n\n  /**\n   * @name revoke\n   * @api public\n   */\n  revoke(token, hint) {\n    assert(this.issuer.revocation_endpoint, 'issuer must be configured with revocation endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n\n    const body = { token };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('revocation', { body })\n      .then((response) => {\n        if (response.body) {\n          return JSON.parse(response.body);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * @name introspect\n   * @api public\n   */\n  introspect(token, hint) {\n    assert(this.issuer.introspection_endpoint, 'issuer must be configured with introspection endpoint');\n    assert(!hint || typeof hint === 'string', 'hint must be a string');\n\n    const body = { token };\n    if (hint) body.token_type_hint = hint;\n    return this.authenticatedPost('introspection', { body })\n      .then(expectResponseWithBody(200))\n      .then(response => JSON.parse(response.body));\n  }\n\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n  fetchDistributedClaims(claims, tokens = {}) {\n    const distributedSources = _.pickBy(claims._claim_sources, def => !!def.endpoint);\n\n    return Promise.all(_.map(distributedSources, (def, sourceName) => {\n      const opts = {\n        headers: { Authorization: bearer(def.access_token || tokens[sourceName]) },\n      };\n\n      return this.httpClient.get(def.endpoint, this.issuer.httpOptions(opts))\n        .then(response => claimJWT.call(this, response.body), errorHandler.bind(this))\n        .then((data) => {\n          delete claims._claim_sources[sourceName];\n          _.forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n        }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n  unpackAggregatedClaims(claims) {\n    const aggregatedSources = _.pickBy(claims._claim_sources, def => !!def.JWT);\n\n    return Promise.all(_.map(aggregatedSources, (def, sourceName) => {\n      const decoded = claimJWT.call(this, def.JWT);\n\n      return decoded.then((data) => {\n        delete claims._claim_sources[sourceName];\n        _.forEach(claims._claim_names, assignClaim(claims, data, sourceName));\n      }).catch(assignErrSrc(sourceName));\n    })).then(() => cleanUpClaims(claims));\n  }\n\n  /**\n   * @name authenticatedPost\n   * @api private\n   */\n  authenticatedPost(endpoint, httpOptions) {\n    return Promise.resolve(this.authFor(endpoint))\n      .then((auth) => {\n        const opts = this.issuer.httpOptions(_.merge(httpOptions, auth, { form: true }));\n        return this.httpClient.post(this.issuer[`${endpoint}_endpoint`], opts);\n      })\n      .catch(errorHandler.bind(this));\n  }\n\n  /**\n   * @name createSign\n   * @api private\n   */\n  createSign(endpoint) {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n    switch (this[`${endpoint}_endpoint_auth_method`]) {\n      case 'client_secret_jwt':\n        return this.joseSecret().then((key) => {\n          if (!alg) {\n            alg = _.find(\n              this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`],\n              signAlg => key.algorithms('sign').includes(signAlg)\n            );\n          }\n\n          return jose.JWS.createSign({\n            fields: { alg, typ: 'JWT' },\n            format,\n          }, { key, reference: false });\n        });\n      case 'private_key_jwt': {\n        if (!alg) {\n          const algz = _.chain(instance(this).keystore.all())\n            .map(key => key.algorithms('sign'))\n            .flatten()\n            .uniq()\n            .value();\n\n          alg = _.find(\n            this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`],\n            signAlg => algz.includes(signAlg)\n          );\n        }\n\n        const key = instance(this).keystore.get({ alg, use: 'sig' });\n        assert(key, 'no valid key found');\n\n        return Promise.resolve(jose.JWS.createSign({\n          fields: { alg, typ: 'JWT' },\n          format,\n        }, { key, reference: true }));\n      }\n      /* istanbul ignore next */\n      default:\n        throw new Error('createSign only works for _jwt token auth methods');\n    }\n  }\n\n  /**\n   * @name authFor\n   * @api private\n   */\n  authFor(endpoint) {\n    switch (this[`${endpoint}_endpoint_auth_method`] || this.token_endpoint_auth_method) {\n      case 'none':\n        return {\n          body: {\n            client_id: this.client_id,\n          },\n        };\n      case 'client_secret_post':\n        return {\n          body: {\n            client_id: this.client_id,\n            client_secret: this.client_secret,\n          },\n        };\n      case 'private_key_jwt':\n      case 'client_secret_jwt': {\n        const timestamp = now();\n        return this.createSign(endpoint).then(sign => sign.update(JSON.stringify({\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: uuid(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: this.issuer[`${endpoint}_endpoint`],\n        })).final().then((client_assertion) => { // eslint-disable-line camelcase, arrow-body-style\n          return {\n            body: {\n              client_assertion,\n              client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',\n            },\n          };\n        }));\n      }\n      default: {\n        const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n        const value = Buffer.from(encoded).toString('base64');\n        return { headers: { Authorization: `Basic ${value}` } };\n      }\n    }\n  }\n\n\n  /**\n   * @name inspect\n   * @api public\n   */\n  inspect() {\n    return util.format('Client <%s>', this.client_id);\n  }\n\n  /**\n   * @name register\n   * @api public\n   */\n  static register(properties, { initialAccessToken, keystore } = {}) {\n    assert(this.issuer.registration_endpoint, 'issuer does not support dynamic registration');\n\n    if (keystore !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      checkStore.call(this, keystore);\n      properties.jwks = keystore.toJSON();\n    }\n\n    const headers = { 'Content-Type': 'application/json' };\n\n    if (initialAccessToken) headers.Authorization = bearer(initialAccessToken);\n\n    return this.httpClient.post(this.issuer.registration_endpoint, this.issuer.httpOptions({\n      headers,\n      body: JSON.stringify(properties),\n    }))\n      .then(expectResponseWithBody(201))\n      .then(response => new this(JSON.parse(response.body), keystore))\n      .catch(errorHandler.bind(this));\n  }\n\n  get metadata() {\n    return instance(this).metadata;\n  }\n\n  /**\n   * @name fromUri\n   * @api public\n   */\n  static fromUri(uri, token, keystore) {\n    return this.httpClient.get(uri, this.issuer.httpOptions({\n      headers: { Authorization: bearer(token) },\n    }))\n      .then(expectResponseWithBody(200))\n      .then(response => new this(JSON.parse(response.body), keystore), errorHandler.bind(this));\n  }\n\n  /**\n   * @name requestObject\n   * @api public\n   */\n  requestObject(request = {}, algorithms = {}) {\n    assert.equal(typeof request, 'object', 'pass an object as the first argument');\n\n    _.defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc,\n      },\n    }, {\n      sign: 'none',\n    });\n\n    const signed = (() => {\n      const alg = algorithms.sign;\n      const header = { alg, typ: 'JWT' };\n      const payload = JSON.stringify(_.defaults({}, request, {\n        iss: this.client_id,\n        aud: this.issuer.issuer,\n        client_id: this.client_id,\n      }));\n\n      if (alg === 'none') {\n        return Promise.resolve([\n          base64url.encode(JSON.stringify(header)),\n          base64url.encode(payload),\n          '',\n        ].join('.'));\n      }\n\n      const symmetrical = alg.startsWith('HS');\n\n      const getKey = (() => {\n        if (symmetrical) return this.joseSecret();\n        const { keystore } = instance(this);\n\n        assert(keystore, `no keystore present for client, cannot sign using ${alg}`);\n        const key = keystore.get({ alg, use: 'sig' });\n        assert(key, `no key to sign with found for ${alg}`);\n        return Promise.resolve(key);\n      })();\n\n      return getKey\n        .then(key => jose.JWS.createSign({\n          fields: header,\n          format,\n        }, { key, reference: !symmetrical }))\n        .then(sign => sign.update(payload).final());\n    })();\n\n    if (!algorithms.encrypt.alg) return signed;\n    const fields = { alg: algorithms.encrypt.alg, enc: algorithms.encrypt.enc, cty: 'JWT' };\n\n    let keystoreOrSecret;\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      keystoreOrSecret = this.issuer.key({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc',\n      }, true);\n    } else {\n      keystoreOrSecret = this.joseSecret(fields.alg);\n    }\n\n    /* eslint-disable arrow-body-style */\n    return keystoreOrSecret.then((key) => {\n      return signed.then((cleartext) => {\n        return jose.JWE.createEncrypt({ format, fields }, { key, reference: key.kty !== 'oct' })\n          .update(cleartext)\n          .final();\n      });\n    });\n    /* eslint-enable arrow-body-style */\n  }\n\n  get httpClient() {\n    return this.issuer.httpClient;\n  }\n\n  static get httpClient() {\n    return this.issuer.httpClient;\n  }\n}\n\nmodule.exports = Client;\n"]},"metadata":{},"sourceType":"script"}